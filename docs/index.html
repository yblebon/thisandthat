<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cartoon Timeline - Sticky Stack Mode</title>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    <style>
        :root {
            --bg-color: #fafaf9; --text-color: #1a1a1a; --card-bg: #ffffff;
            --border-color: #000000; --accent-yellow: #fef08a; --accent-red: #ef4444;
            --header-height: 60px;
        }
        body.dark-mode { --bg-color: #121212; --text-color: #fbbf24; --card-bg: #1e1e1e; --border-color: #fbbf24; }
        
        body { font-family: 'Comic Sans MS', cursive; background: var(--bg-color); color: var(--text-color); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        
        .container { 
            display: flex; flex-direction: column; gap: 20px; 
            width: 100%; max-width: 800px; margin-top: 40px; 
            padding-bottom: 60vh; 
        }
        
        /* THE KEY: STICKY HEADERS */
        .card { 
            background: var(--card-bg); border: 2px solid var(--border-color); border-radius: 8px; 
            box-shadow: 6px 6px 0px var(--border-color); overflow: visible; height: fit-content;
        }
        
        .card-header { 
            position: sticky; 
            top: 0; /* They will stack at the top of the viewport */
            z-index: 10;
            padding: 15px 20px; border-bottom: 2px solid var(--border-color); 
            display: flex; justify-content: space-between; align-items: center; 
            font-weight: 900; text-transform: uppercase; cursor: pointer; 
            background: var(--card-bg); /* Must be solid to cover content behind it */
        }

        .status-badge {
            font-size: 0.7rem; border: 2px solid var(--border-color); 
            padding: 2px 8px; border-radius: 4px; background: var(--card-bg);
        }

        .timeline { 
            padding: 20px 15px; display: none; 
            background-image: radial-gradient(var(--border-color) 0.5px, transparent 0.5px); 
            background-size: 18px 18px; 
        }
        .timeline.active { display: block; }

        /* BUBBLES */
        .message { display: flex; margin-bottom: 25px; gap: 12px; }
        .message.left { flex-direction: row; }
        .message.right { flex-direction: row-reverse; }
        .avatar { width: 44px; height: 44px; border-radius: 50%; border: 2px solid var(--border-color); flex-shrink: 0; background: #eee; }
        .message-content { max-width: 80%; padding: 10px 14px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--card-bg); box-shadow: 3px 3px 0px var(--border-color); position: relative; }

        .attachment { margin-top: 10px; border-radius: 4px; overflow: hidden; border: 1px solid var(--border-color); }
        .youtube-placeholder { width: 100%; aspect-ratio: 16/9; background: #000; display: flex; align-items: center; justify-content: center; cursor: pointer; color: white; font-weight: bold; }
        iframe, video { width: 100%; aspect-ratio: 16/9; display: block; border: none; }
        audio { width: 100%; height: 40px; }
        
        .username { font-weight: 900; font-size: 0.7rem; color: var(--accent-red); text-transform: uppercase; }
        .dialog-date { font-size: 0.6rem; margin-top: 6px; opacity: 0.6; text-align: right; }
    </style>
</head>
<body>

    <h1 style="font-size: 2.5rem; text-align: center;">COMIC <span style="color: var(--accent-red);">TIMELINE</span></h1>
    <div class="container" id="container"></div>

    <script>
        function getYTId(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function stopMedia(container) {
            container.querySelectorAll('video, audio').forEach(m => { m.pause(); m.currentTime = 0; });
            container.querySelectorAll('.youtube-lite').forEach(wrapper => {
                wrapper.innerHTML = `<div class="youtube-placeholder">▶ PLAY VIDEO</div>`;
            });
        }

        function closeAllCards(exceptCard) {
            document.querySelectorAll('.card').forEach(card => {
                if (card !== exceptCard) {
                    const timeline = card.querySelector('.timeline');
                    const badge = card.querySelector('.status-badge');
                    if (timeline.classList.contains('active')) {
                        timeline.classList.remove('active');
                        badge.textContent = 'OPEN';
                        stopMedia(timeline);
                    }
                }
            });
        }

        function createAttachmentHTML(attach) {
            if (!attach) return '';
            const type = attach.type.toLowerCase();
            switch (type) {
                case 'video':
                    const ytId = getYTId(attach.url);
                    return ytId ? `<div class="attachment youtube-lite" data-ytid="${ytId}"><div class="youtube-placeholder">▶ PLAY VIDEO</div></div>` :
                                  `<div class="attachment"><video controls preload="none" src="${attach.url}"></video></div>`;
                case 'audio': return `<div class="attachment"><audio controls preload="none" src="${attach.url}"></audio></div>`;
                case 'image': return `<div class="attachment"><img src="${attach.url}" style="width:100%" loading="lazy"></div>`;
                case 'xpost': return `<div class="attachment">${attach.embedCode || ''}</div>`;
                default: return '';
            }
        }

        const container = document.getElementById('container');

        container.addEventListener('click', (e) => {
            const card = e.target.closest('.card');
            if (!card) return;

            if (e.target.closest('.youtube-placeholder')) {
                const wrapper = e.target.closest('.youtube-lite');
                wrapper.innerHTML = `<iframe src="https://www.youtube.com/embed/${wrapper.dataset.ytid}?autoplay=1" allow="autoplay; encrypted-media" allowfullscreen></iframe>`;
                return;
            }

            if (e.target.closest('.card-header')) {
                const timeline = card.querySelector('.timeline');
                const badge = card.querySelector('.status-badge');
                const isOpening = !timeline.classList.contains('active');

                if (isOpening) {
                    closeAllCards(card);
                    timeline.classList.add('active');
                    badge.textContent = 'CLOSE';
                    if (window.twttr) window.twttr.widgets.load(timeline);

                    // CENTER LOGIC WITH STICKY AWARENESS
                    setTimeout(() => {
                        const cardTop = card.getBoundingClientRect().top + window.pageYOffset;
                        const viewportHeight = window.innerHeight;
                        // Subtracting a bit of height to account for the sticky headers at the top
                        const targetPos = cardTop - (viewportHeight / 4); 

                        window.scrollTo({ top: targetPos, behavior: 'smooth' });
                    }, 100);
                } else {
                    timeline.classList.remove('active');
                    badge.textContent = 'OPEN';
                    stopMedia(timeline);
                }
            }
        });

        async function init() {
            try {
                const res = await fetch('https://raw.githubusercontent.com/yblebon/datasources/refs/heads/main/conversations.json');
                const data = await res.json();
                data.forEach((conv) => {
                    const card = document.createElement('div');
                    card.className = 'card';
                    const messagesHTML = conv.messages.map(m => {
                        const sideClass = (m.sender === 'right' || m.sender === 'me') ? 'right' : 'left';
                        return `<div class="message ${sideClass}">
                                    <img class="avatar" src="${m.photoUrl}" loading="lazy">
                                    <div class="message-content">
                                        <div class="username">${m.username}</div>
                                        <div style="font-size: 0.9rem;">${m.text}</div>
                                        ${createAttachmentHTML(m.attachment)}
                                        <div class="dialog-date">${m.timestamp || ''}</div>
                                    </div>
                                </div>`;
                    }).join('');

                    card.innerHTML = `<div class="card-header"><span>${conv.name}</span><span class="status-badge">OPEN</span></div>
                                      <div class="timeline">${messagesHTML}</div>`;
                    container.appendChild(card);
                });
            } catch (err) { console.error(err); }
        }
        init();
    </script>
</body>
</html>